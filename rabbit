// app.js
const producer = require('./producer');
const consumer = require('./consumer');

const logger = require('winston');

/**
 * Sends a message to a queue using a producer and consumes the message from the queue using a consumer.
 * Handles any errors that occur during the process.
 */
async function main() {
  try {
    if (producer.isConnected() && consumer.isConnected()) {
      logger.info('Sending message to queue...');
      await producer.sendToQueue(message);
      logger.info('Message sent to queue.');

      // Consume the message from the queue using the consumer
      try {
        await consumer.consumeFromQueue();
        logger.info('Message consumed from queue.');
      } catch (error) {
        logger.error('Error consuming message from queue:', error);
      }
    } else {
      logger.error('Producer or consumer is not connected.');
    }
  } catch (error) {
    logger.error('Error sending message to queue:', error);
  } finally {
    try {
      await producer.disconnect();
    } catch (error) {
      logger.error('Error disconnecting producer:', error);
    }
    try {
      await consumer.disconnect();
    } catch (error) {
      logger.error('Error disconnecting consumer:', error);
    }
  }
}

module.exports = main;
async function consumeMessageFromQueue() {
  try {
    logger.info('Consuming message from queue...');
    await consumer.consumeFromQueue();
    logger.info('Message consumed from queue.');
  } catch (error) {
    logger.error('Error:', error);
  }
}

async function main() {
  try {
    if (producer.isConnected() && consumer.isConnected()) {
      await sendMessageToQueue();
      await consumeMessageFromQueue();
    } else {
      logger.error('Producer or consumer is not connected.');
    }
  } catch (error) {
    logger.error('Error:', error);
  }
}

// Check if producer and consumer are connected before calling sendToQueue and consumeFromQueue
async function main() {
  if (producer.isConnected() && consumer.isConnected()) {
    try {
      console.log('Sending message to queue...');
      await producer.sendToQueue('hello');
      console.log('Message sent to queue.');

      console.log('Consuming message from queue...');
      await consumer.consumeFromQueue();
      console.log('Message consumed from queue.');
    } catch (error) {
      console.log('Error:', error);
    }
  } else {
    console.log('Producer or consumer is not connected.');
  }
}

// Execute producer.sendToQueue and consumer.consumeFromQueue concurrently using Promise.all
async function main() {
  try {
    console.log('Sending message to queue...');
    console.log('Consuming message from queue...');
    await Promise.all([producer.sendToQueue('hello'), consumer.consumeFromQueue()]);
    console.log('Message sent to queue.');
    console.log('Message consumed from queue.');
  } catch (error) {
    console.log('Error:', error);
  }
}

// Use a message broker or event-driven architecture for better scalability and decoupling
async function main() {
  try {
    console.log('Publishing message to message broker...');
    await messageBroker.publish('hello');
    console.log('Message published to message broker.');
  } catch (error) {
    console.log('Error:', error);
  }
}

main().catch(console.error);
